import { ApiPromise } from "@polkadot/api";
import type { ISubmittableResult, IKeyringPair } from "@polkadot/types/types";
import BN from "bn.js";
/**
 * @name initializeApi
 * @summary Initialize substrate api with selected or default wss endpoint.
 * @description The default chainEndpoint is "wss://alphanet.ternoa.com"
 * @param chain Chain endpoint
 */
export declare const initializeApi: (chain?: string) => Promise<void>;
/**
 * @name getApi
 * @summary Get initialized substrate Api instance.
 * @returns Promise containing the actual Api instance, a wrapper around the RPC and interfaces of the chain.
 */
export declare const getApi: () => Promise<ApiPromise>;
/**
 * @name isApiConnected
 * @summary Check if the Api instance existed and if it is connected.
 * @returns Boolean, true if the underlying provider is connected, false otherwise
 */
export declare const isApiConnected: () => boolean;
/**
 * @name getApiEndpoint
 * @summary Provides the wss api endpoint
 * @returns String, the api endpoint connected with.
 */
export declare const getApiEndpoint: () => Promise<string>;
/**
 * @name safeDisconnect
 * @summary Disconnect safely from the underlying provider, halting all network traffic
 */
export declare const safeDisconnect: () => Promise<void>;
/**
 * @name query
 * @summary Generic function to make a chain query.
 * @example
 * <BR>
 *
 * ```javascript
 * // you can query without any args
 * const data = await query('balances', 'totalIssuance');
 *
 * // or you can pass args parameters to the storage query
 * const data = await query('system', 'account', ['5GesFQSwhmuMKAHcDrfm21Z5xrq6kW93C1ch2Xosq1rXx2Eh']);
 *
 * ```
 * @param module The section required to make the chain query (eg. "system")
 * @param call The call depending on the section (eg. "account")
 * @param args Array of args for the call
 * @param callback Callback function to enable subscription, if not given, no subscription will be made
 * @returns Result of the query storage call
 */
export declare const query: (module: string, call: string, args?: any[], callback?: ((result: any) => void) | undefined) => Promise<import("@polkadot/types/types").Codec>;
/**
 * @name consts
 * @summary Generic function to get a chain constant.
 * @example
 * <BR>
 *
 * ```javascript
 * console.log(api.consts.balances.existentialDeposit.toString())
 * ```
 *
 * @param section The section required to get the chain constant (eg. "balances")
 * @param constantName The constantName depending on the section (eg. "existentialDeposit")
 * @returns The constant value
 */
export declare const consts: (section: string, constantName: string) => Promise<import("@polkadot/types/types").Codec>;
/**
 * @name isTransactionSuccess
 * @summary Check if a transaction result is successful.
 * @param result Generic result passed as a parameter in a transaction callback
 * @returns Object containing a boolean success field indicating if transaction is successful
 * and a indexInterrupted field to indicate where the transaction stopped in case of a batch
 */
export declare const isTransactionSuccess: (result: ISubmittableResult) => {
    success: boolean;
    indexInterrupted?: number | undefined;
};
/**
 * @name checkTxAvailable
 * @summary Check if the pallet module and the subsequent extrinsic method exist in the Api instance.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @returns Boolean, true if the pallet module and the subsequent extrinsic method exist, throw an Error otherwise
 */
export declare const checkTxAvailable: (txPallet: string, txExtrinsic: string) => Promise<boolean>;
/**
 * @name createTxHex
 * @summary Create a transaction in hex format.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @param txArgs Arguments of the transaction
 * @returns Hex value of the transaction
 */
export declare const createTxHex: (txPallet: string, txExtrinsic: string, txArgs?: any[]) => Promise<`0x${string}`>;
/**
 * @name signTx
 * @summary Sign a transaction.
 * @param keyring Keyring pair to sign the data
 * @param txHex Tx hex of the unsigned transaction to be signed
 * @returns Hex value of the signed transaction
 */
export declare const signTx: (keyring: IKeyringPair, txHex: `0x${string}`) => Promise<`0x${string}`>;
/**
 * @name submitTx
 * @summary Send a signed transaction on the blockchain.
 * @param txHex Transaction hex of the signed transaction to be submitted
 * @param callback Callback function to enable subscription, if not given, no subscription will be made
 * @returns Hash of the transaction
 */
export declare const submitTx: (txHex: `0x${string}`, callback?: ((result: ISubmittableResult) => void) | undefined) => Promise<`0x${string}`>;
/**
 * @name runTx
 * @summary Create, sign and submit a transaction on blockchain.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @param txArgs Arguments of the transaction
 * @param keyring Keyring pair to sign the data, if not given, an unsigned transaction to be signed will be returned
 * @param callback Callback function to enable subscription, if not given, no subscription will be made
 * @returns Hash of the transaction, or an unsigned transaction to be signed if no keyring pair is passed
 */
export declare const runTx: (txPallet: string, txExtrinsic: string, txArgs: any[], keyring?: IKeyringPair | undefined, callback?: ((result: ISubmittableResult) => void) | undefined) => Promise<`0x${string}`>;
/**
 * @name batchTx
 * @summary Create a batch transaction of dispatch calls.
 * @param txHexes Transactions to execute in the batch call
 * @returns Submittable extrinsic unsigned
 */
export declare const batchTx: (txHexes: `0x${string}`[]) => Promise<import("@polkadot/api-base/types").SubmittableExtrinsic<"promise", ISubmittableResult>>;
/**
 * @name batchTxHex
 * @summary Create a batch transaction of dispatch calls in hex format.
 * @param txHexes Transactions to execute in the batch call
 * @returns Hex of the submittable extrinsic unsigned
 */
export declare const batchTxHex: (txHexes: `0x${string}`[]) => Promise<`0x${string}`>;
/**
 * @name batchAllTx
 * @summary Create a batchAll transaction of dispatch calls.
 * @param txHexes Transactions to execute in the batch call
 * @returns Submittable extrinsic unsigned
 */
export declare const batchAllTx: (txHexes: `0x${string}`[]) => Promise<import("@polkadot/api-base/types").SubmittableExtrinsic<"promise", ISubmittableResult>>;
/**
 * @name batchAllTxHex
 * @summary Create a batchAll transaction of dispatch calls in hex format.
 * @param txHexes Transactions to execute in the batch call
 * @returns Hex of the submittable extrinsic unsigned
 */
export declare const batchAllTxHex: (txHexes: `0x${string}`[]) => Promise<`0x${string}`>;
/**
 * @name isValidAddress
 * @summary Check if an address is a valid Ternoa address.
 * @param address
 * @returns Boolean, true if the address is valid, false otherwise
 */
export declare const isValidAddress: (address: string) => boolean;
/**
 * @name unFormatBalance
 * @summary Format balance from number to BN.
 * @param _input Number input
 * @returns BN output
 */
export declare const unFormatBalance: (_input: number) => Promise<BN>;
