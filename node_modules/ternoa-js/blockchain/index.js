"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unFormatBalance = exports.isValidAddress = exports.batchAllTxHex = exports.batchAllTx = exports.batchTxHex = exports.batchTx = exports.runTx = exports.submitTx = exports.signTx = exports.createTxHex = exports.checkTxAvailable = exports.isTransactionSuccess = exports.consts = exports.query = exports.safeDisconnect = exports.getApiEndpoint = exports.isApiConnected = exports.getApi = exports.initializeApi = void 0;
var util_crypto_1 = require("@polkadot/util-crypto");
var api_1 = require("@polkadot/api");
var keyring_1 = require("@polkadot/keyring");
var util_1 = require("@polkadot/util");
var bn_js_1 = __importDefault(require("bn.js"));
var constants_1 = require("../constants");
var fee_1 = require("../fee");
var types_1 = require("./types");
var DEFAULT_CHAIN_ENDPOINT = "wss://alphanet.ternoa.com";
var api;
var chainEndpoint = DEFAULT_CHAIN_ENDPOINT;
/**
 * @name initializeApi
 * @summary Initialize substrate api with selected or default wss endpoint.
 * @description The default chainEndpoint is "wss://alphanet.ternoa.com"
 * @param chain Chain endpoint
 */
var initializeApi = function (chain) {
    if (chain === void 0) { chain = chainEndpoint; }
    return __awaiter(void 0, void 0, void 0, function () {
        var wsProvider;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, util_crypto_1.cryptoWaitReady)()];
                case 1:
                    _a.sent();
                    (0, exports.safeDisconnect)();
                    wsProvider = new api_1.WsProvider(chain);
                    return [4 /*yield*/, api_1.ApiPromise.create({
                            provider: wsProvider,
                            types: types_1.types,
                        })];
                case 2:
                    api = _a.sent();
                    chainEndpoint = chain;
                    return [2 /*return*/];
            }
        });
    });
};
exports.initializeApi = initializeApi;
/**
 * @name getApi
 * @summary Get initialized substrate Api instance.
 * @returns Promise containing the actual Api instance, a wrapper around the RPC and interfaces of the chain.
 */
var getApi = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!!(0, exports.isApiConnected)()) return [3 /*break*/, 2];
                return [4 /*yield*/, (0, exports.initializeApi)()];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2: return [2 /*return*/, api];
        }
    });
}); };
exports.getApi = getApi;
/**
 * @name isApiConnected
 * @summary Check if the Api instance existed and if it is connected.
 * @returns Boolean, true if the underlying provider is connected, false otherwise
 */
var isApiConnected = function () {
    return Boolean(api && api.isConnected);
};
exports.isApiConnected = isApiConnected;
/**
 * @name getApiEndpoint
 * @summary Provides the wss api endpoint
 * @returns String, the api endpoint connected with.
 */
var getApiEndpoint = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                _a.sent();
                return [2 /*return*/, chainEndpoint];
        }
    });
}); };
exports.getApiEndpoint = getApiEndpoint;
/**
 * @name safeDisconnect
 * @summary Disconnect safely from the underlying provider, halting all network traffic
 */
var safeDisconnect = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(0, exports.isApiConnected)()) return [3 /*break*/, 2];
                return [4 /*yield*/, api.disconnect()];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2: return [2 /*return*/];
        }
    });
}); };
exports.safeDisconnect = safeDisconnect;
/**
 * @name query
 * @summary Generic function to make a chain query.
 * @example
 * <BR>
 *
 * ```javascript
 * // you can query without any args
 * const data = await query('balances', 'totalIssuance');
 *
 * // or you can pass args parameters to the storage query
 * const data = await query('system', 'account', ['5GesFQSwhmuMKAHcDrfm21Z5xrq6kW93C1ch2Xosq1rXx2Eh']);
 *
 * ```
 * @param module The section required to make the chain query (eg. "system")
 * @param call The call depending on the section (eg. "account")
 * @param args Array of args for the call
 * @param callback Callback function to enable subscription, if not given, no subscription will be made
 * @returns Result of the query storage call
 */
var query = function (module, call, args, callback) {
    if (args === void 0) { args = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        var api;
        var _a, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, (0, exports.getApi)()];
                case 1:
                    api = _c.sent();
                    if (!!callback) return [3 /*break*/, 3];
                    return [4 /*yield*/, (_a = api.query[module])[call].apply(_a, args)];
                case 2: return [2 /*return*/, _c.sent()];
                case 3: return [4 /*yield*/, (_b = api.query[module])[call].apply(_b, __spreadArray(__spreadArray([], args, false), [function (result) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, callback(result)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }], false))];
                case 4: return [2 /*return*/, _c.sent()];
            }
        });
    });
};
exports.query = query;
/**
 * @name consts
 * @summary Generic function to get a chain constant.
 * @example
 * <BR>
 *
 * ```javascript
 * console.log(api.consts.balances.existentialDeposit.toString())
 * ```
 *
 * @param section The section required to get the chain constant (eg. "balances")
 * @param constantName The constantName depending on the section (eg. "existentialDeposit")
 * @returns The constant value
 */
var consts = function (section, constantName) { return __awaiter(void 0, void 0, void 0, function () {
    var api;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                return [2 /*return*/, api.consts[section][constantName]];
        }
    });
}); };
exports.consts = consts;
/**
 * @name isTransactionSuccess
 * @summary Check if a transaction result is successful.
 * @param result Generic result passed as a parameter in a transaction callback
 * @returns Object containing a boolean success field indicating if transaction is successful
 * and a indexInterrupted field to indicate where the transaction stopped in case of a batch
 */
var isTransactionSuccess = function (result) {
    if (!(result.status.isInBlock || result.status.isFinalized))
        throw new Error("Transaction is not finalized or in block");
    var isFailed = result.events.findIndex(function (item) { return item.event.section === constants_1.txPallets.system && item.event.method === constants_1.txEvent.ExtrinsicFailed; }) !== -1;
    var indexInterrupted = result.events.findIndex(function (item) { return item.event.section === constants_1.txPallets.utility && item.event.method === constants_1.txEvent.BatchInterrupted; });
    var isInterrupted = indexInterrupted !== -1;
    return {
        success: !isFailed && !isInterrupted,
        indexInterrupted: isInterrupted ? indexInterrupted : undefined,
    };
};
exports.isTransactionSuccess = isTransactionSuccess;
/**
 * @name checkTxAvailable
 * @summary Check if the pallet module and the subsequent extrinsic method exist in the Api instance.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @returns Boolean, true if the pallet module and the subsequent extrinsic method exist, throw an Error otherwise
 */
var checkTxAvailable = function (txPallet, txExtrinsic) { return __awaiter(void 0, void 0, void 0, function () {
    var api;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                try {
                    api.tx[txPallet][txExtrinsic];
                    return [2 /*return*/, true];
                }
                catch (err) {
                    throw new Error("".concat(txPallet, "_").concat(txExtrinsic, " not found, check the selected endpoint"));
                }
                return [2 /*return*/];
        }
    });
}); };
exports.checkTxAvailable = checkTxAvailable;
/**
 * @name createTx
 * @summary Create a transaction.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @param txArgs Arguments of the transaction
 * @returns Transaction object unsigned
 */
var createTx = function (txPallet, txExtrinsic, txArgs) {
    if (txArgs === void 0) { txArgs = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        var api;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, (0, exports.getApi)()];
                case 1:
                    api = _b.sent();
                    return [4 /*yield*/, (0, exports.checkTxAvailable)(txPallet, txExtrinsic)];
                case 2:
                    _b.sent();
                    return [2 /*return*/, (_a = api.tx[txPallet])[txExtrinsic].apply(_a, txArgs)];
            }
        });
    });
};
/**
 * @name createTxHex
 * @summary Create a transaction in hex format.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @param txArgs Arguments of the transaction
 * @returns Hex value of the transaction
 */
var createTxHex = function (txPallet, txExtrinsic, txArgs) {
    if (txArgs === void 0) { txArgs = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, createTx(txPallet, txExtrinsic, txArgs)];
                case 1:
                    tx = _a.sent();
                    return [2 /*return*/, tx.toHex()];
            }
        });
    });
};
exports.createTxHex = createTxHex;
/**
 * @name signTx
 * @summary Sign a transaction.
 * @param keyring Keyring pair to sign the data
 * @param txHex Tx hex of the unsigned transaction to be signed
 * @returns Hex value of the signed transaction
 */
var signTx = function (keyring, txHex) { return __awaiter(void 0, void 0, void 0, function () {
    var api, txSigned;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                return [4 /*yield*/, api.tx(txHex).signAsync(keyring, { nonce: -1, blockHash: api.genesisHash, era: 0 })];
            case 2:
                txSigned = _a.sent();
                return [2 /*return*/, txSigned.toHex()];
        }
    });
}); };
exports.signTx = signTx;
/**
 * @name submitTx
 * @summary Send a signed transaction on the blockchain.
 * @param txHex Transaction hex of the signed transaction to be submitted
 * @param callback Callback function to enable subscription, if not given, no subscription will be made
 * @returns Hash of the transaction
 */
var submitTx = function (txHex, callback) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx, unsub_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                tx = api.tx(txHex);
                return [4 /*yield*/, (0, fee_1.checkFundsForTxFees)(tx)];
            case 2:
                _a.sent();
                if (!(callback === undefined)) return [3 /*break*/, 4];
                return [4 /*yield*/, tx.send()];
            case 3:
                _a.sent();
                return [3 /*break*/, 6];
            case 4: return [4 /*yield*/, tx.send(function (result) { return __awaiter(void 0, void 0, void 0, function () {
                    var err_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, callback(result)];
                            case 1:
                                _a.sent();
                                if (result.status.isFinalized) {
                                    unsub_1();
                                }
                                return [3 /*break*/, 3];
                            case 2:
                                err_1 = _a.sent();
                                unsub_1();
                                throw err_1;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); })];
            case 5:
                unsub_1 = _a.sent();
                _a.label = 6;
            case 6: return [2 /*return*/, tx.hash.toHex()];
        }
    });
}); };
exports.submitTx = submitTx;
/**
 * @name runTx
 * @summary Create, sign and submit a transaction on blockchain.
 * @param txPallet Pallet module of the transaction
 * @param txExtrinsic Subsequent extrinsic method of the transaction
 * @param txArgs Arguments of the transaction
 * @param keyring Keyring pair to sign the data, if not given, an unsigned transaction to be signed will be returned
 * @param callback Callback function to enable subscription, if not given, no subscription will be made
 * @returns Hash of the transaction, or an unsigned transaction to be signed if no keyring pair is passed
 */
var runTx = function (txPallet, txExtrinsic, txArgs, keyring, callback) { return __awaiter(void 0, void 0, void 0, function () {
    var signableTx, signedTx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.createTxHex)(txPallet, txExtrinsic, txArgs)];
            case 1:
                signableTx = _a.sent();
                if (!keyring)
                    return [2 /*return*/, signableTx];
                return [4 /*yield*/, (0, exports.signTx)(keyring, signableTx)];
            case 2:
                signedTx = _a.sent();
                return [4 /*yield*/, (0, exports.submitTx)(signedTx, callback)];
            case 3: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.runTx = runTx;
/**
 * @name batchTx
 * @summary Create a batch transaction of dispatch calls.
 * @param txHexes Transactions to execute in the batch call
 * @returns Submittable extrinsic unsigned
 */
var batchTx = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                tx = createTx(constants_1.txPallets.utility, constants_1.txActions.batch, [txHexes.map(function (x) { return api.tx(x); })]);
                return [2 /*return*/, tx];
        }
    });
}); };
exports.batchTx = batchTx;
/**
 * @name batchTxHex
 * @summary Create a batch transaction of dispatch calls in hex format.
 * @param txHexes Transactions to execute in the batch call
 * @returns Hex of the submittable extrinsic unsigned
 */
var batchTxHex = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.batchTx)(txHexes)];
            case 1:
                tx = _a.sent();
                return [2 /*return*/, tx.toHex()];
        }
    });
}); };
exports.batchTxHex = batchTxHex;
/**
 * @name batchAllTx
 * @summary Create a batchAll transaction of dispatch calls.
 * @param txHexes Transactions to execute in the batch call
 * @returns Submittable extrinsic unsigned
 */
var batchAllTx = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                tx = createTx(constants_1.txPallets.utility, constants_1.txActions.batchAll, [txHexes.map(function (x) { return api.tx(x); })]);
                return [2 /*return*/, tx];
        }
    });
}); };
exports.batchAllTx = batchAllTx;
/**
 * @name batchAllTxHex
 * @summary Create a batchAll transaction of dispatch calls in hex format.
 * @param txHexes Transactions to execute in the batch call
 * @returns Hex of the submittable extrinsic unsigned
 */
var batchAllTxHex = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.batchAllTx)(txHexes)];
            case 1:
                tx = _a.sent();
                return [2 /*return*/, tx.toHex()];
        }
    });
}); };
exports.batchAllTxHex = batchAllTxHex;
/**
 * @name isValidAddress
 * @summary Check if an address is a valid Ternoa address.
 * @param address
 * @returns Boolean, true if the address is valid, false otherwise
 */
var isValidAddress = function (address) {
    try {
        (0, keyring_1.encodeAddress)((0, util_1.isHex)(address) ? (0, util_1.hexToU8a)(address) : (0, keyring_1.decodeAddress)(address));
        return true;
    }
    catch (error) {
        return false;
    }
};
exports.isValidAddress = isValidAddress;
/**
 * @name unFormatBalance
 * @summary Format balance from number to BN.
 * @param _input Number input
 * @returns BN output
 */
var unFormatBalance = function (_input) { return __awaiter(void 0, void 0, void 0, function () {
    var input, api, siPower, basePower, siUnitPower, isDecimalValue, result, div, modString, mod;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                input = String(_input);
                return [4 /*yield*/, (0, exports.getApi)()];
            case 1:
                api = _a.sent();
                siPower = new bn_js_1.default(api.registry.chainDecimals[0]);
                basePower = api.registry.chainDecimals[0];
                siUnitPower = 0;
                isDecimalValue = input.match(/^(\d+)\.(\d+)$/);
                if (isDecimalValue) {
                    if (siUnitPower - isDecimalValue[2].length < -basePower) {
                        result = new bn_js_1.default(-1);
                    }
                    div = new bn_js_1.default(input.replace(/\.\d*$/, ""));
                    modString = input.replace(/^\d+\./, "").substring(0, api.registry.chainDecimals[0] + 1);
                    mod = new bn_js_1.default(modString);
                    result = div.mul(util_1.BN_TEN.pow(siPower)).add(mod.mul(util_1.BN_TEN.pow(new bn_js_1.default(basePower + siUnitPower - modString.length))));
                }
                else {
                    result = new bn_js_1.default(input.replace(/[^\d]/g, "")).mul(util_1.BN_TEN.pow(siPower));
                }
                return [2 /*return*/, result];
        }
    });
}); };
exports.unFormatBalance = unFormatBalance;
